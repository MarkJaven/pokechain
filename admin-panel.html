<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Admin Panel</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
    <style>
        body { font-family: Arial; padding: 20px; background: #1a1a2e; color: white; }
        .container { max-width: 800px; margin: 0 auto; }
        .card { background: rgba(0,0,0,0.3); padding: 20px; margin: 10px 0; border-radius: 10px; }
        .btn { background: #00ff9d; color: black; border: none; padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .btn-danger { background: #ff4444; }
        .btn-warning { background: #ffaa00; }
        input { padding: 10px; width: 300px; margin: 5px; }
        pre { background: #000; padding: 10px; overflow: auto; }
        .loading { display: none; color: #00ff9d; margin: 5px; }
        .status { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background: rgba(0, 255, 157, 0.2); }
        .error { background: rgba(255, 68, 68, 0.2); }
        .info { background: rgba(255, 170, 0, 0.2); }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tournament Admin Panel</h1>
        
        <div class="card">
            <h3>1. Check PKCN Minter Status</h3>
            <button class="btn" onclick="checkMinter()">Check Minter</button>
            <div id="minterStatus"></div>
        </div>
        
        <div class="card">
            <h3>2. Set Tournament as PKCN Minter</h3>
            <p>Only PKCN owner can do this</p>
            <button class="btn btn-warning" onclick="setMinter()">Set Tournament as Minter</button>
            <div id="setMinterResult"></div>
        </div>
        
        <div class="card">
            <h3>3. Fix Specific Tournament</h3>
            <input type="text" id="fixTournamentId" placeholder="Enter Tournament ID">
            <button class="btn" onclick="checkTournament()">Check Tournament State</button>
            <button class="btn btn-danger" onclick="forceExpireTournament()">Force Expire Tournament</button>
            <button class="btn btn-warning" onclick="forceCompleteTournament()">Force Complete Tournament</button>
            <div id="tournamentStatus" class="status"></div>
        </div>
        
        <div class="card">
            <h3>4. View All Tournaments for Address</h3>
            <input type="text" id="playerAddress" placeholder="Player Address (leave empty for current)">
            <button class="btn" onclick="viewPlayerTournaments()">View Player Data</button>
            <pre id="playerData"></pre>
        </div>
        
        <div class="card">
            <h3>5. Emergency Admin Functions</h3>
            <button class="btn btn-danger" onclick="emergencyExpireAll()">Emergency Expire All Active</button>
            <button class="btn btn-warning" onclick="fixMinterIfOwner()">Auto-Fix Minter (If Owner)</button>
            <button class="btn" onclick="debugBigInt()">Debug BigInt Issue</button>
            <div id="emergencyStatus" class="status"></div>
        </div>
    </div>

    <script src="config.js"></script>
    <script>
        const CONFIG = window.CONTRACTS;
        let provider, signer, pkcnContract, tournamentContract;
        
        // Enhanced tournament ABI with all needed functions
        const TOURNAMENT_ABI = [
            // Tournament management
            "function tournaments(string) view returns (address player, uint256 tokenId, string difficulty, uint256 wins, uint256 totalMatches, bool isActive, bool isExpired, bool isCompleted, bool rewardClaimed, uint256 startBlock, uint256 entryFee, uint256 finalReward)",
            "function expireTournament(string tournamentId) external",
            "function forceCompleteTournament(string tournamentId, uint256 wins, bool isPerfect) external",
            "function completeTournament(string tournamentId, uint256 wins, bool isPerfect) external",
            "function claimReward(string tournamentId) external",
            
            // Player data
            "function getPlayerTournaments(address player) view returns (string[] memory)",
            "function getActiveTournament(address player) view returns (string tournamentId, bool exists, bool expired)",
            "function getUnclaimedRewards(address player) view returns (string[] memory tournamentIds, uint256[] memory rewards)",
            
            // Admin functions
            "function owner() view returns (address)",
            "function isAdmin(address) view returns (bool)",
            "function setAdmin(address admin, bool status) external",
            
            // Emergency functions
            "function emergencyExpireAll() external onlyOwner",
            "function fixTournamentState(string tournamentId, bool active, bool completed, bool claimed) external onlyOwner"
        ];
        
        const PKCN_ABI = [
            "function minter() view returns (address)",
            "function setMinter(address newMinter) external",
            "function mint(address to, uint256 amount) external",
            "function owner() view returns (address)",
            "function balanceOf(address) view returns (uint256)"
        ];
        
        // Helper function to safely convert BigInt to Number
        function safeNumber(value) {
            if (typeof value === 'bigint') {
                // Check if it fits in JavaScript's safe integer range
                if (value > BigInt(Number.MAX_SAFE_INTEGER) || value < BigInt(Number.MIN_SAFE_INTEGER)) {
                    // Return as string to avoid precision loss
                    return value.toString();
                }
                return Number(value);
            }
            return value;
        }
        
        // Helper to format BigInt values for display
        function formatBigInt(value) {
            if (typeof value === 'bigint') {
                return value.toString();
            }
            return value;
        }
        
        async function init() {
            try {
                if (!window.ethereum) {
                    showStatus('minterStatus', '‚ö†Ô∏è Install MetaMask first', 'error');
                    return false;
                }
                
                // Request accounts
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (!accounts || accounts.length === 0) {
                    showStatus('minterStatus', '‚ö†Ô∏è Please connect your wallet', 'error');
                    return false;
                }
                
                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
                
                // Initialize contracts
                pkcnContract = new ethers.Contract(CONFIG.PKCN, PKCN_ABI, signer);
                tournamentContract = new ethers.Contract(CONFIG.TOURNAMENT, TOURNAMENT_ABI, signer);
                
                console.log("‚úÖ Contracts initialized");
                console.log("Connected address:", await signer.getAddress());
                console.log("PKCN Address:", CONFIG.PKCN);
                console.log("Tournament Address:", CONFIG.TOURNAMENT);
                
                return true;
            } catch (error) {
                console.error("Initialization error:", error);
                showStatus('minterStatus', `‚ùå Initialization failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        function showStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="${type}">${message}</div>`;
        }
        
        async function checkMinter() {
            if (!await init()) return;
            
            try {
                const minter = await pkcnContract.minter();
                const tournamentAddr = CONFIG.TOURNAMENT;
                const isMinter = minter.toLowerCase() === tournamentAddr.toLowerCase();
                
                const statusHtml = `
                    <div class="status ${isMinter ? 'success' : 'error'}">
                        <p><strong>Current PKCN Minter:</strong> ${minter}</p>
                        <p><strong>Tournament Address:</strong> ${tournamentAddr}</p>
                        <p><strong>Status:</strong> ${isMinter ? '‚úÖ Tournament IS minter' : '‚ùå Tournament is NOT minter'}</p>
                        ${!isMinter ? '<p style="color: #ff4444;">‚ö†Ô∏è This is why rewards cannot be claimed! Use "Set Tournament as Minter" if you are PKCN owner.</p>' : ''}
                    </div>
                `;
                
                document.getElementById('minterStatus').innerHTML = statusHtml;
            } catch (error) {
                showStatus('minterStatus', `‚ùå Error: ${error.message}`, 'error');
            }
        }
        
        async function setMinter() {
            if (!await init()) return;
            
            try {
                // Check if caller is owner
                const pkcnOwner = await pkcnContract.owner();
                const caller = await signer.getAddress();
                
                if (pkcnOwner.toLowerCase() !== caller.toLowerCase()) {
                    showStatus('setMinterResult', `‚ùå You are not PKCN owner!<br>Owner: ${pkcnOwner}<br>You: ${caller}`, 'error');
                    return;
                }
                
                const confirm = window.confirm(`Set Tournament (${CONFIG.TOURNAMENT}) as PKCN minter?`);
                if (!confirm) return;
                
                showStatus('setMinterResult', '‚è≥ Sending transaction...', 'info');
                
                const tx = await pkcnContract.setMinter(CONFIG.TOURNAMENT);
                showStatus('setMinterResult', `‚è≥ Transaction sent: ${tx.hash}<br>Waiting for confirmation...`, 'info');
                
                const receipt = await tx.wait();
                if (receipt.status === 1) {
                    showStatus('setMinterResult', '‚úÖ Tournament set as minter successfully!', 'success');
                    checkMinter(); // Refresh status
                } else {
                    showStatus('setMinterResult', '‚ùå Transaction failed', 'error');
                }
            } catch (error) {
                showStatus('setMinterResult', `‚ùå Error: ${error.message}`, 'error');
            }
        }
        
        async function checkTournament() {
            if (!await init()) return;
            
            const tournamentId = document.getElementById('fixTournamentId').value.trim();
            if (!tournamentId) {
                showStatus('tournamentStatus', '‚ö†Ô∏è Please enter a tournament ID', 'error');
                return;
            }
            
            try {
                showStatus('tournamentStatus', '‚è≥ Fetching tournament data...', 'info');
                
                // Get tournament data - FIXED: Properly handle tuple return
                const data = await tournamentContract.tournaments(tournamentId);
                
                // Convert BigInt values to strings for display
                const startBlock = formatBigInt(data.startBlock);
                const entryFee = data.entryFee ? ethers.formatEther(data.entryFee) : '0';
                const finalReward = data.finalReward ? ethers.formatEther(data.finalReward) : '0';
                
                const statusHtml = `
                    <div class="status info">
                        <h4>Tournament ID: ${tournamentId.substring(0, 20)}...</h4>
                        <p><strong>Player:</strong> ${data.player}</p>
                        <p><strong>Difficulty:</strong> ${data.difficulty}</p>
                        <p><strong>Wins:</strong> ${formatBigInt(data.wins)}/${formatBigInt(data.totalMatches)}</p>
                        <p><strong>Status:</strong> ${data.isActive ? 'Active' : 'Inactive'} | 
                           ${data.isCompleted ? 'Completed' : 'Not Completed'} | 
                           ${data.isExpired ? 'Expired' : 'Not Expired'}</p>
                        <p><strong>Reward Claimed:</strong> ${data.rewardClaimed ? 'Yes' : 'No'}</p>
                        <p><strong>Entry Fee:</strong> ${entryFee} ETH</p>
                        <p><strong>Final Reward:</strong> ${finalReward} PKCN</p>
                        <p><strong>Start Block:</strong> ${startBlock}</p>
                    </div>
                `;
                
                document.getElementById('tournamentStatus').innerHTML = statusHtml;
            } catch (error) {
                showStatus('tournamentStatus', `‚ùå Error: ${error.message}`, 'error');
            }
        }
        
        async function forceExpireTournament() {
            if (!await init()) return;
            
            const tournamentId = document.getElementById('fixTournamentId').value.trim();
            if (!tournamentId) {
                showStatus('tournamentStatus', '‚ö†Ô∏è Please enter a tournament ID', 'error');
                return;
            }
            
            try {
                // First check tournament state
                const data = await tournamentContract.tournaments(tournamentId);
                
                if (data.rewardClaimed) {
                    showStatus('tournamentStatus', '‚ö†Ô∏è Reward already claimed. Cannot expire.', 'error');
                    return;
                }
                
                if (data.isExpired) {
                    showStatus('tournamentStatus', '‚ö†Ô∏è Tournament already expired.', 'info');
                    return;
                }
                
                // Get current block - FIXED: Proper BigInt comparison
                const currentBlock = await provider.getBlockNumber();
                const startBlock = data.startBlock;
                
                // Convert to BigInt for safe comparison
                const currentBlockBigInt = BigInt(currentBlock);
                const startBlockBigInt = typeof startBlock === 'bigint' ? startBlock : BigInt(startBlock);
                const blocksPassed = currentBlockBigInt - startBlockBigInt;
                
                let confirmMessage = `Force expire tournament ${tournamentId}?\n\n`;
                confirmMessage += `Player: ${data.player}\n`;
                confirmMessage += `Blocks passed: ${blocksPassed.toString()}\n`;
                confirmMessage += `Entry fee will be lost!\n\n`;
                confirmMessage += `Proceed?`;
                
                if (!window.confirm(confirmMessage)) return;
                
                showStatus('tournamentStatus', '‚è≥ Sending expire transaction...', 'info');
                
                // Call expireTournament function
                const tx = await tournamentContract.expireTournament(tournamentId);
                showStatus('tournamentStatus', `‚è≥ Transaction sent: ${tx.hash}<br>Waiting for confirmation...`, 'info');
                
                const receipt = await tx.wait();
                if (receipt.status === 1) {
                    showStatus('tournamentStatus', '‚úÖ Tournament force expired successfully!', 'success');
                    // Refresh tournament state
                    setTimeout(() => checkTournament(), 2000);
                } else {
                    showStatus('tournamentStatus', '‚ùå Transaction failed', 'error');
                }
            } catch (error) {
                let errorMessage = `‚ùå Error: ${error.message}`;
                
                // Handle common errors
                if (error.message.includes('Tournament not active')) {
                    errorMessage += '\n‚ö†Ô∏è Tournament is not active anymore.';
                } else if (error.message.includes('not expired')) {
                    errorMessage += '\n‚ö†Ô∏è Tournament has not expired yet (1000 blocks required).';
                } else if (error.message.includes('caller is not owner')) {
                    errorMessage += '\n‚ö†Ô∏è Only contract owner can force expire.';
                } else if (error.message.includes('insufficient blocks')) {
                    errorMessage += '\n‚ö†Ô∏è Not enough blocks have passed.';
                } else if (error.message.includes('BigInt')) {
                    errorMessage += '\n‚ö†Ô∏è BigInt conversion error. Try using the "Debug BigInt Issue" button.';
                }
                
                showStatus('tournamentStatus', errorMessage, 'error');
                console.error('Force expire error details:', error);
            }
        }
        
        async function forceCompleteTournament() {
            if (!await init()) return;
            
            const tournamentId = document.getElementById('fixTournamentId').value.trim();
            if (!tournamentId) {
                showStatus('tournamentStatus', '‚ö†Ô∏è Please enter a tournament ID', 'error');
                return;
            }
            
            try {
                // Get tournament data
                const data = await tournamentContract.tournaments(tournamentId);
                
                if (data.isCompleted) {
                    showStatus('tournamentStatus', '‚ö†Ô∏è Tournament already completed.', 'info');
                    return;
                }
                
                // Ask for wins and perfect status
                const winsInput = prompt('Enter number of wins:', formatBigInt(data.wins) || '0');
                if (winsInput === null) return;
                
                // Convert wins to BigInt for contract call
                const winsBigInt = BigInt(winsInput);
                const isPerfect = confirm('Was it a perfect run (all matches won)?');
                
                const confirmMsg = `Force complete tournament?\nWins: ${winsBigInt.toString()}\nPerfect: ${isPerfect}\nProceed?`;
                if (!window.confirm(confirmMsg)) return;
                
                showStatus('tournamentStatus', '‚è≥ Force completing tournament...', 'info');
                
                // Try forceCompleteTournament first (admin function)
                try {
                    const tx = await tournamentContract.forceCompleteTournament(
                        tournamentId,
                        winsBigInt,
                        isPerfect
                    );
                    showStatus('tournamentStatus', `‚è≥ Transaction sent: ${tx.hash}`, 'info');
                    
                    const receipt = await tx.wait();
                    if (receipt.status === 1) {
                        showStatus('tournamentStatus', '‚úÖ Tournament force completed!', 'success');
                        setTimeout(() => checkTournament(), 2000);
                    }
                } catch (error) {
                    // If forceCompleteTournament fails, try regular completeTournament
                    console.warn('forceCompleteTournament failed, trying regular:', error);
                    
                    const tx = await tournamentContract.completeTournament(
                        tournamentId,
                        winsBigInt,
                        isPerfect
                    );
                    
                    const receipt = await tx.wait();
                    if (receipt.status === 1) {
                        showStatus('tournamentStatus', '‚úÖ Tournament completed!', 'success');
                        setTimeout(() => checkTournament(), 2000);
                    }
                }
            } catch (error) {
                showStatus('tournamentStatus', `‚ùå Error: ${error.message}`, 'error');
            }
        }
        
        async function viewPlayerTournaments() {
            if (!await init()) return;
            
            let address = document.getElementById('playerAddress').value.trim();
            if (!address) {
                address = await signer.getAddress();
            }
            
            try {
                document.getElementById('playerData').textContent = 'Loading...';
                
                let output = `Player: ${address}\n\n`;
                
                // Get active tournament
                try {
                    const activeData = await tournamentContract.getActiveTournament(address);
                    output += `ACTIVE TOURNAMENT:\n`;
                    output += `  ID: ${activeData[0] || "None"}\n`;
                    output += `  Exists: ${activeData[1]}\n`;
                    output += `  Expired: ${activeData[2]}\n\n`;
                } catch (e) {
                    output += `ACTIVE TOURNAMENT: Error - ${e.message}\n\n`;
                }
                
                // Get all player tournaments
                try {
                    const allTournaments = await tournamentContract.getPlayerTournaments(address);
                    output += `ALL TOURNAMENTS (${allTournaments.length}):\n`;
                    
                    for (const id of allTournaments) {
                        try {
                            const data = await tournamentContract.tournaments(id);
                            output += `\n  ${id.substring(0, 20)}...:\n`;
                            output += `    Status: ${data.isActive ? 'Active' : 'Inactive'} | `;
                            output += `${data.isCompleted ? 'Completed' : 'Not'} | `;
                            output += `${data.isExpired ? 'Expired' : 'Not'}\n`;
                            output += `    Wins: ${formatBigInt(data.wins)}/${formatBigInt(data.totalMatches)}\n`;
                            output += `    Claimed: ${data.rewardClaimed}\n`;
                        } catch (e) {
                            output += `  ${id.substring(0, 20)}...: Error fetching data\n`;
                        }
                    }
                } catch (e) {
                    output += `ALL TOURNAMENTS: Error - ${e.message}\n`;
                }
                
                // Get unclaimed rewards
                try {
                    const [tournamentIds, rewards] = await tournamentContract.getUnclaimedRewards(address);
                    output += `\nUNCLAIMED REWARDS (${tournamentIds.length}):\n`;
                    for (let i = 0; i < tournamentIds.length; i++) {
                        const rewardAmount = rewards[i] ? ethers.formatEther(rewards[i]) : '0';
                        output += `  ${i+1}. ${tournamentIds[i].substring(0, 20)}... - ${rewardAmount} PKCN\n`;
                    }
                } catch (e) {
                    output += `\nUNCLAIMED REWARDS: Error - ${e.message}\n`;
                }
                
                document.getElementById('playerData').textContent = output;
            } catch (error) {
                document.getElementById('playerData').textContent = `Error: ${error.message}`;
            }
        }
        
        async function emergencyExpireAll() {
            if (!await init()) return;
            
            try {
                // Check if caller is owner
                const owner = await tournamentContract.owner();
                const caller = await signer.getAddress();
                
                if (owner.toLowerCase() !== caller.toLowerCase()) {
                    showStatus('emergencyStatus', `‚ùå Only contract owner can use this!<br>Owner: ${owner}<br>You: ${caller}`, 'error');
                    return;
                }
                
                if (!window.confirm('‚ö†Ô∏è EMERGENCY: Expire ALL active tournaments?\nThis will expire every active tournament in the contract!\nProceed?')) {
                    return;
                }
                
                showStatus('emergencyStatus', '‚è≥ Executing emergency expire all...', 'info');
                
                try {
                    const tx = await tournamentContract.emergencyExpireAll();
                    showStatus('emergencyStatus', `‚è≥ Transaction sent: ${tx.hash}`, 'info');
                    
                    const receipt = await tx.wait();
                    if (receipt.status === 1) {
                        showStatus('emergencyStatus', '‚úÖ All active tournaments force expired!', 'success');
                    }
                } catch (error) {
                    showStatus('emergencyStatus', `‚ùå Error: ${error.message}<br>Try force expiring tournaments individually.`, 'error');
                }
            } catch (error) {
                showStatus('emergencyStatus', `‚ùå Error: ${error.message}`, 'error');
            }
        }
        
        async function fixMinterIfOwner() {
            if (!await init()) return;
            
            try {
                const pkcnOwner = await pkcnContract.owner();
                const caller = await signer.getAddress();
                
                if (pkcnOwner.toLowerCase() !== caller.toLowerCase()) {
                    showStatus('emergencyStatus', `‚ùå You are not PKCN owner!<br>Owner: ${pkcnOwner}`, 'error');
                    return;
                }
                
                const minter = await pkcnContract.minter();
                const tournamentAddr = CONFIG.TOURNAMENT;
                
                if (minter.toLowerCase() === tournamentAddr.toLowerCase()) {
                    showStatus('emergencyStatus', '‚úÖ Tournament is already minter', 'success');
                    return;
                }
                
                if (!window.confirm(`Set Tournament (${tournamentAddr}) as PKCN minter?`)) return;
                
                const tx = await pkcnContract.setMinter(tournamentAddr);
                showStatus('emergencyStatus', `‚è≥ Setting minter... ${tx.hash}`, 'info');
                
                const receipt = await tx.wait();
                if (receipt.status === 1) {
                    showStatus('emergencyStatus', '‚úÖ Tournament set as minter!', 'success');
                }
            } catch (error) {
                showStatus('emergencyStatus', `‚ùå Error: ${error.message}`, 'error');
            }
        }
        
        async function debugBigInt() {
            if (!await init()) return;
            
            const tournamentId = document.getElementById('fixTournamentId').value.trim();
            if (!tournamentId) {
                showStatus('emergencyStatus', '‚ö†Ô∏è Enter a tournament ID first', 'error');
                return;
            }
            
            try {
                showStatus('emergencyStatus', 'üîç Debugging BigInt issue...', 'info');
                
                // Get tournament data
                const data = await tournamentContract.tournaments(tournamentId);
                
                let debugOutput = `Tournament ID: ${tournamentId}\n\n`;
                debugOutput += `Data types:\n`;
                
                // Check each field type
                for (const [key, value] of Object.entries(data)) {
                    debugOutput += `  ${key}: ${value} (type: ${typeof value})\n`;
                }
                
                debugOutput += `\nstartBlock value: ${data.startBlock}\n`;
                debugOutput += `startBlock type: ${typeof data.startBlock}\n`;
                debugOutput += `startBlock as string: ${data.startBlock?.toString()}\n`;
                
                // Test block number
                const currentBlock = await provider.getBlockNumber();
                debugOutput += `\nCurrent block: ${currentBlock} (type: ${typeof currentBlock})\n`;
                
                // Try conversion
                const startBlockValue = data.startBlock;
                const currentBlockValue = currentBlock;
                
                debugOutput += `\nConversion test:\n`;
                debugOutput += `  BigInt(currentBlock): ${BigInt(currentBlockValue)}\n`;
                debugOutput += `  typeof BigInt(currentBlock): ${typeof BigInt(currentBlockValue)}\n`;
                
                if (typeof startBlockValue === 'bigint') {
                    debugOutput += `  startBlock is already BigInt: ${startBlockValue}\n`;
                    debugOutput += `  Blocks passed (BigInt): ${BigInt(currentBlockValue) - startBlockValue}\n`;
                } else {
                    debugOutput += `  Converting startBlock to BigInt: ${BigInt(startBlockValue)}\n`;
                }
                
                showStatus('emergencyStatus', `<pre>${debugOutput}</pre>`, 'info');
                
                // Test direct expire call
                debugOutput += `\n\nTesting expire function call:\n`;
                try {
                    // Try a simple call
                    debugOutput += `  Calling expireTournament(${tournamentId})...\n`;
                    
                    // Use a gas estimate to test
                    const gasEstimate = await tournamentContract.expireTournament.estimateGas(tournamentId);
                    debugOutput += `  Gas estimate: ${gasEstimate}\n`;
                    
                    showStatus('emergencyStatus', `<pre>${debugOutput}</pre>`, 'info');
                    
                } catch (estError) {
                    debugOutput += `  Estimate error: ${estError.message}\n`;
                    showStatus('emergencyStatus', `<pre>${debugOutput}</pre>`, 'error');
                }
                
            } catch (error) {
                showStatus('emergencyStatus', `‚ùå Debug error: ${error.message}`, 'error');
            }
        }
        
        // Initialize on load
        window.addEventListener('load', function() {
            console.log("Admin Panel Loaded");
            console.log("PKCN Address:", CONFIG?.PKCN);
            console.log("Tournament Address:", CONFIG?.TOURNAMENT);
            
            // Auto-populate with current tournament ID if available
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const tournamentId = urlParams.get('tournamentId') || 
                                   localStorage.getItem('currentTournamentId');
                if (tournamentId) {
                    document.getElementById('fixTournamentId').value = tournamentId;
                }
            } catch (e) {
                console.log("Could not auto-populate tournament ID");
            }
        });
    </script>
</body>
</html>